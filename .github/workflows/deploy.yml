name: Deploy to Kubernetes

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: archiit19/customer-service-go
  NAMESPACE: customer-service
  AWS_REGION: ${{ vars.AWS_REGION || 'eu-north-1' }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        env:
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          if [ -z "$KUBE_CONFIG_B64" ]; then
            echo "KUBE_CONFIG secret is empty; add a base64-encoded kubeconfig to the repository secrets." >&2
            exit 1
          fi
          mkdir -p "$HOME/.kube"
          CONFIG_PATH="$HOME/.kube/config"
          printf '%s' "$KUBE_CONFIG_B64" | base64 --decode > "$CONFIG_PATH"
          chmod 600 "$CONFIG_PATH"
          echo "KUBECONFIG=$CONFIG_PATH" >> "$GITHUB_ENV"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check cluster connectivity
        run: kubectl cluster-info

      - name: Create namespace
        run: kubectl apply -f deploy/minikube/00-namespace.yaml

      - name: Create image pull secret
        env:
          REGISTRY_USERNAME: ${{ secrets.GHCR_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.GHCR_TOKEN }}
          FALLBACK_USERNAME: ${{ github.actor }}
          FALLBACK_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
        run: |
          USERNAME="${REGISTRY_USERNAME:-$FALLBACK_USERNAME}"
          PASSWORD="${REGISTRY_PASSWORD:-$FALLBACK_PASSWORD}"
          if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            echo "Container registry credentials are missing. Set GHCR_USERNAME/GHCR_TOKEN secrets or rely on GITHUB_TOKEN." >&2
            exit 1
          fi
          kubectl create secret docker-registry ghcr-credentials \
            --namespace ${{ env.NAMESPACE }} \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username="$USERNAME" \
            --docker-password="$PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Attach image pull secret to default service account
        run: |
          kubectl patch serviceaccount default \
            --namespace ${{ env.NAMESPACE }} \
            --type merge \
            -p '{"imagePullSecrets":[{"name":"ghcr-credentials"}]}'

      - name: Create database credentials secret
        run: |
          kubectl create secret generic customer-service-db-secret \
            --namespace ${{ env.NAMESPACE }} \
            --from-literal=DB_USER='${{ secrets.DB_USER }}' \
            --from-literal=DB_PASSWORD='${{ secrets.DB_PASSWORD }}' \
            --from-literal=POSTGRES_USER='${{ secrets.DB_USER }}' \
            --from-literal=POSTGRES_PASSWORD='${{ secrets.DB_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply config map and services
        run: |
          kubectl apply -f deploy/minikube/configmap.yaml
          kubectl apply -f deploy/minikube/postgres.yaml
          kubectl apply -f deploy/minikube/service.yaml
          kubectl apply -f deploy/minikube/deployment.yaml
          kubectl apply -f deploy/minikube/ingress.yaml

      - name: Wait for database rollout
        run: kubectl rollout status deployment/postgres -n ${{ env.NAMESPACE }} --timeout=180s

      - name: Run database migrations
        run: |
          set -euo pipefail
          POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=postgres -o jsonpath='{.items[0].metadata.name}')
          for file in $(find migrations -maxdepth 1 -type f -name '*.sql' | sort); do
            base=$(basename "$file")
            kubectl cp "$file" "${{ env.NAMESPACE }}/$POD:/tmp/$base"
            kubectl exec -n ${{ env.NAMESPACE }} "$POD" -- env PGPASSWORD='${{ secrets.DB_PASSWORD }}' \
              psql --host=localhost --username='${{ secrets.DB_USER }}' --dbname='customerdb' --file="/tmp/$base"
          done

      - name: Update deployment image
        run: |
          kubectl set image deployment/customer-service customer-service=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            --namespace ${{ env.NAMESPACE }}

      - name: Wait for service rollout
        run: kubectl rollout status deployment/customer-service -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Show cluster resources
        run: |
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get svc -n ${{ env.NAMESPACE }}
          kubectl get ingress -n ${{ env.NAMESPACE }}
