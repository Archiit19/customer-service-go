name: Deploy to Kubernetes

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NAMESPACE: customer-service

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          mkdir -p "$HOME/.kube"
          echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"

      - name: Create namespace
        run: kubectl apply -f deploy/minikube/00-namespace.yaml

      - name: Create image pull secret
        run: |
          kubectl create secret docker-registry ghcr-credentials \
            --namespace ${{ env.NAMESPACE }} \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username='${{ secrets.GHCR_USERNAME }}' \
            --docker-password='${{ secrets.GHCR_TOKEN }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Attach image pull secret to default service account
        run: |
          kubectl patch serviceaccount default \
            --namespace ${{ env.NAMESPACE }} \
            --type merge \
            -p '{"imagePullSecrets":[{"name":"ghcr-credentials"}]}'

      - name: Create database credentials secret
        run: |
          kubectl create secret generic customer-service-db-secret \
            --namespace ${{ env.NAMESPACE }} \
            --from-literal=DB_USER='${{ secrets.DB_USER }}' \
            --from-literal=DB_PASSWORD='${{ secrets.DB_PASSWORD }}' \
            --from-literal=POSTGRES_USER='${{ secrets.DB_USER }}' \
            --from-literal=POSTGRES_PASSWORD='${{ secrets.DB_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply config map and services
        run: |
          kubectl apply -f deploy/minikube/configmap.yaml
          kubectl apply -f deploy/minikube/postgres.yaml
          kubectl apply -f deploy/minikube/service.yaml
          kubectl apply -f deploy/minikube/deployment.yaml
          kubectl apply -f deploy/minikube/ingress.yaml

      - name: Wait for database rollout
        run: kubectl rollout status deployment/postgres -n ${{ env.NAMESPACE }} --timeout=180s

      - name: Run database migrations
        run: |
          set -euo pipefail
          POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=postgres -o jsonpath='{.items[0].metadata.name}')
          for file in $(find migrations -maxdepth 1 -type f -name '*.sql' | sort); do
            base=$(basename "$file")
            kubectl cp "$file" "${{ env.NAMESPACE }}/$POD:/tmp/$base"
            kubectl exec -n ${{ env.NAMESPACE }} "$POD" -- env PGPASSWORD='${{ secrets.DB_PASSWORD }}' \
              psql --host=localhost --username='${{ secrets.DB_USER }}' --dbname='customerdb' --file="/tmp/$base"
          done

      - name: Update deployment image
        run: |
          kubectl set image deployment/customer-service customer-service=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            --namespace ${{ env.NAMESPACE }}

      - name: Wait for service rollout
        run: kubectl rollout status deployment/customer-service -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Show cluster resources
        run: |
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get svc -n ${{ env.NAMESPACE }}
          kubectl get ingress -n ${{ env.NAMESPACE }}
